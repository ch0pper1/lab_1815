{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#connect-watsonx-assistant-to-your-business-data-using-custom-extensions","title":"Connect watsonx Assistant to your Business Data using Custom Extensions","text":"<p>This hands on lab is designed to show you how to create an API and document it so that it can be used by watsonx Assistant.  The lab will start by creating an OpenAPI specification and generating code from it.  After local testing is complete, the API will be connected to the Assistant and tested. These advanced techniques can be used for any situation or customization of an existing API.  At the end of the lab, users can incorporate this knowledge into their custom demonstrations, POCs, and MVPs.  General programming skills and watsonx Assistant Action skills necessary. </p> <p>We will discuss three key areas:</p> <ul> <li>Building the OpenAPI Specification</li> <li>Deploy the API service</li> <li>Connecting your API to watsonx Assistant</li> </ul>"},{"location":"#creating-an-api","title":"Creating an API","text":"<p>This can be anything that can provide information to your conversational AI platforrm.  From a third-party weather API to the latest LLM for generative AI capabilities.  The API can also be built in any desired programming language.</p> <p>For the purposes of this lab, we will focus on using Python and LangChain to connect to a watsonx.ai foundation model.</p>"},{"location":"#building-an-openapi-specification","title":"Building an OpenAPI Specification","text":"<p>watsonx Assistant requires OpenAPI spec version 3.0.  This lab will will cover the tools to use in order to create a valid specification that watsonx Assistant will be able to ingest.</p>"},{"location":"#connect-to-watsonx-assistant","title":"Connect to watsonx Assistant","text":"<p>Once everything is created and working, it is time to connect to watsonx Assistant to test the API by building an Action that calls the extension and displays the returned data.</p>"},{"location":"appendices/","title":"Index","text":""},{"location":"appendices/#other-methods-of-generator-installation","title":"Other methods of generator installation","text":""},{"location":"appendices/#using-wsl","title":"Using WSL","text":"<p>There is also a nodejs application that can be installed locally.  To do this, open the command prompt to run the command <code>wsl --install -d Debian</code> to install a Debian based image under the Windows Subsystem for Linux (WSL).  Add a username and password to complete the install process.</p> <p>Now that there is a linux terminal to use, we can go through the process of install nodejs and the openapi generator.  Perform the following steps to do so:</p> <ol> <li><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></li> <li><code>sudo apt install -y nodejs npm</code></li> <li><code>npm install @openapitools/openapi-generator-cli -g</code></li> </ol>"},{"location":"appendices/glossary/","title":"Glossary","text":"<p>A brief list of acronyms and definitions</p> Term Definition API Application Programming Interface CLI Command Line Interface REST REpresentational State Transfer WA watsonx Assistant JSON JavaScript Object Notation IDE Integrated Development Environment OpenAPI New standard for creating specifications that define an application programming interface WSL Windows Subsystem for Linux YAML Yet Another Markup Language"},{"location":"appendices/helpful-links/","title":"Helpful links","text":""},{"location":"appendices/helpful-links/#useful-links-and-documentation","title":"Useful links and documentation","text":"<ul> <li>Swagger UI - Great free tool for creating API specs.</li> <li>OpenAPI v3.0 specification - Documentation for version 3.0 of the OpenAPI specification</li> <li>watsonx Assistant Custom Extension Documentation</li> <li>OpenAPI Server generators</li> <li>OpenAPI public generator API</li> </ul>"},{"location":"conclusion/conclusion/","title":"Conclusion","text":"<p>In this lab, you've embarked on a journey to harness the power of Watsonx Assistant by connecting it to your business data using custom extensions. You've gained valuable insights into advanced techniques that can be applied to various scenarios and customization needs, which can significantly enhance your conversational AI capabilities.</p> <p>Throughout this lab, you've delved into three key areas:</p> <p>Building an OpenAPI Specification: You've become acquainted with the crucial role of OpenAPI specifications in enabling Watsonx Assistant to seamlessly integrate with your API. With an emphasis on OpenAPI spec version 3.0, you've familiarized yourself with the necessary tools and techniques for creating a valid specification that Watsonx Assistant can easily digest.</p> <p>Creating an API: You've learned how to craft a custom API tailored to your specific requirements. Whether it's fetching weather data from a third-party source or tapping into the latest generative AI capabilities, you now possess the skills to build APIs in the programming language of your choice. In our case, we explored creating a Python-based API that interacts with a simple users API.  To further your skills, you can go the watsonx Assistant Starter-Kits to look at pre-built custom extensions, including connecting the Assistant to watsonx.ai for LLM generative AI use cases.</p> <p>Connecting to Watsonx Assistant: Finally, you've reached the culmination of this journey, where you've connected your API to Watsonx Assistant. By building an Action that calls the extension and displays the returned data, you've seen how the pieces of this intricate puzzle come together. This connection allows you to test your API within the Watsonx Assistant environment, ensuring that it operates as expected and provides valuable data to enhance your conversational AI experiences.</p> <p>As you wrap up this lab, remember that the knowledge and skills you've acquired here can extend beyond the confines of this exercise. You can now apply these techniques to your custom demonstrations, proof-of-concepts (POCs), and minimum viable products (MVPs). By doing so, you'll be better equipped to leverage Watsonx Assistant's capabilities to meet your specific business needs and elevate your conversational AI projects to new heights.</p> <p>So, as you move forward, keep experimenting, innovating, and exploring the endless possibilities that Watsonx Assistant and custom extensions offer. Your journey into the world of conversational AI has just begun, and the potential for transformative solutions is limitless. Happy coding!</p>"},{"location":"connect-wa/connect-wa/","title":"Lab 1815 - Connect your API to watsonx Assistant","text":"<p>An instance of watsonx Assistant has been provisioned for the purposes of this lab.  Follow these steps to create an Assistant:</p> <ol> <li>Login to the IBM Cloud and provide the user credentials for your student ID.</li> <li>Ensure that you are using the correct account.  If not, select the itzenablement64 account from the Account list in the upper right. </li> <li>You should see the watsonx Assistant Service in the Resource List.  Click on the name and then Press \"Launch Assistant\" </li> <li>You will need to create a new assistant to get started.  Provide a name and description, then answer the questions on the proceeding pages. </li> </ol> <p>From here, we can now add our extension and an action to call out to it.</p>"},{"location":"connect-wa/connect-wa/#adding-a-custom-extension","title":"Adding a Custom Extension","text":"<p>Adding the extension is done on the Integrations page of the Assistant.  In the lower left corner, select Integrations, then scroll down to the \"Build custom extension button\". </p> <p> </p> <p>From here, step through the process of adding the openapi.json file that was created earlier in this lab.  Once completed, there will be a tile on the Integrations page that will have your custom extension.  Now, you can add the server address and other information necessary by clicking on the Add + button.</p> <p></p> <p>After pressing next and moving to the Authentication page, the specifics for the API can be added.  For the purposes of this lab, no API key or authentication is necessary.  The server URL will still need to be added though.  Add this at the bottom of the screen in the Server variables section.</p> Note <p>If you are using your own API, then you may have to add the credentials in this section.  Please verify with the API provider for the necessary format.</p> <p></p>"},{"location":"connect-wa/connect-wa/#create-an-action-that-calls-the-extension","title":"Create an action that calls the extension","text":"<p>In the example specification, the API provides information about a user or creates a user with the supplied information.  To create an Action in Assistant, you will need to gather the information necessary to call the API.  </p> <p>To begin, create a new Action from scratch.  Give a few examples of how a customer would start this conversation.</p> <p>Now, you can add a step to ask for the user's name.  To do this, have the Assistant ask the question, then in Define User Response, choose Free Text as the type of input.  The next step will ask for this user's email address.  In the user response, there is a predefined regex type that will look for email patterns.</p> <p></p> <p>With a new step, we will call the custom extension.  In the bottom section \"And then...\", choose the Use an extension option to open a new window and call your extension.  Choose the custom extension added for this lab, then in the name field, select Action Step Variable and select the response for step one.  Then do the same for the email.</p> <p></p> <p>Now that the extension is called, we can check to see if it ran successfully and respond to the user.  If the extension returns information, then this data will be stored in a variable that can be presented to the end user. You can also end the Action as no further steps will be needed.</p>"},{"location":"connect-wa/connect-wa/#test-the-extension","title":"Test the extension","text":"<p>To test the Assistant and calling the extension, use the Preview button in the bottom right of the Actions section.  This tool provides many features that help test and troubleshoot both the Action and the extension.</p> <p>If there is an error when calling the extension, you can use the Inspect tool to see what was sent and received from the extension.  There are other options for checking the values of session and action variables.</p> <p></p> <p>Whenever an extension is called, there is a Ran Successfully variable that is created to ensure that the extension completed without errors.  This variable can be used as a condition for further steps to ensure using the data returned is available.</p> <p></p> <p>Once you have called the extension successfully and showed data within the Assistant chat session, you have completed this lab!</p>"},{"location":"create-api/build-api-from-spec/","title":"Todo: replace this first sentence","text":"<p>Once the API definitions have been created and documented, the API needs to be served online so that watsonx Assistant can access the endpoints and retrieve the information.  For the purposes of this lab, we will use <code>openapi-generator-cli</code> to create the stub code, then serve the code using IBM's Code Engine.</p>"},{"location":"create-api/build-api-from-spec/#create-the-python-code","title":"Create the Python code","text":""},{"location":"create-api/build-api-from-spec/#install-node-and-the-generator","title":"Install Node and the Generator","text":"<p>To create the stub code, the OpenAPI team has provided an online generator tool that can be used to supply your JSON file and create the code.  We can also install the tool locally using the following steps:</p>"},{"location":"create-api/build-api-from-spec/#using-scoop","title":"Using scoop","text":"<ol> <li>Install scoop <pre><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser\nirm get.scoop.sh | iex\n</code></pre></li> <li>Install dependencies and application <pre><code>scoop install git\nscoop bucket add java\nscoop install java/openjdk\nscoop install openapi-generator-cli\n</code></pre></li> </ol>"},{"location":"create-api/build-api-from-spec/#using-wsl","title":"Using WSL","text":"<p>There is also a nodejs application that can be installed locally.  To do this, open the command prompt to run the command <code>wsl --install -d Debian</code> to install a Debian based image under the Windows Subsystem for Linux (WSL).  Add a username and password to complete the install process.</p> <p>Now that there is a linux terminal to use, we can go through the process of install nodejs and the openapi generator.  Perform the following steps to do so:</p> <ol> <li><code>sudo apt update &amp;&amp; sudo apt upgrade -y</code></li> <li><code>sudo apt install -y nodejs npm</code></li> <li><code>npm install @openapitools/openapi-generator-cli -g</code></li> </ol>"},{"location":"create-api/build-api-from-spec/#create-the-code","title":"Create the code","text":"<p>Now that the tool is installed locally, we can generate the stub code and modify it as necessary.  To Generate the code, use the following command:</p> <pre><code>openapi-generator-cli generate -g python-flask -i .\\Documents\\project\\openapi.json -o .\\Documents\\project\\server\n</code></pre> <p>In the above command, there are a few things to note.  First, the <code>-g</code> flag defines the type of code that will be created.  This example chose <code>python-flask</code>, but there are several other server options that are listed here.  The <code>-i</code> flag defines the specification file that was previously created.  Finally, the <code>-i</code> flag sets where the code will be created.  This command will need to be modified based on the individual environment and file locations.</p> <p>Congratulations, you now have working code that serves the APIs defined in the openapi specification file!  Once running, the service will respond to API requests, which can be tested with <code>curl</code> commands locally.  The next step wil be to deploy the service into IBM's Code Engine for testing with watsonx Assistant.</p>"},{"location":"create-api/create-api/","title":"Lab 1815 - Creating the API","text":""},{"location":"create-api/create-api/#what-you-will-need","title":"What you will need","text":"<ul> <li>Your choice of API.  This can be one of the following:<ul> <li>Python</li> <li>Node JS</li> <li>PHP</li> <li>Go</li> <li>Other*</li> </ul> </li> <li>Knowledge of REST API requests</li> <li>A text editor or Programming IDE</li> </ul> A note on programming languages <p>Any programming language that provides REST modules can be used.  The ones listed above are just the languages that can be used with IBM's Cloud Functions</p>"},{"location":"create-api/create-api/#getting-started","title":"Getting Started","text":"<p>There are several methods to create a REST API and each programming language will provide its own methodologies.  This lab will cover how to setup a basic API that will return a JSON object that can be used by watsonx Assistant for context data.  The key is to create a well defined API that can then be used to create the openapi documentation which WA will use.</p>"},{"location":"create-api/create-api/#build-the-api","title":"Build the API","text":"<p>For the purposes of this lab, the API will be built using python with the Flask module for http communication.  This module will need to be installed and then imported into the program.</p> <p>install Flask<pre><code>pip install flask\n</code></pre> This will install the necessary module files for the application to run.</p> <p>server.py<pre><code>from flask import Flask,jsonify\n</code></pre> The import command will associate the modules needed for responding to API requests and return JSON objects in the response.</p>"},{"location":"create-api/create-api/#instantiate-the-flask-application-and-add-an-endpoint","title":"Instantiate the Flask application and add an endpoint","text":"<p>Now that the necessary modules are installed and imported, it is time to create the application to serve the API. Here is the basic structure to the API application: server.py<pre><code>app = Flask(__name__)\n@app.route('/users', methods=['GET', 'POST'])\ndef test():\nreturn jsonify({ \"response\": \"yes, this worked.\" })\nif __name__ == '__main__':\napp.run(host='0.0.0.0', port=9001)\n</code></pre></p> <p>This simple application exposes a single url, or route, to return a JSON object with a response element.  From here, you can test this by running a curl command <code>curl -X GET http://localhost:9001/test</code> to ensure it is working.  The response should look like this: <pre><code>{\n\"response\": \"yes, this worked.\"\n}\n</code></pre></p> <p>Now that data can be returned via API, the next step is to document the API and test it using IBM Code Engine and watsonx Assistant.</p>"},{"location":"create-api/deploy-to-code-engine/","title":"Lab 1815 - Deploy the application to IBM Code Engine","text":"<p>Now that the application has been tested and ready to deploy, we can use IBM Code Engine to host the service.  To access the code engine CLI, we will need to install the ibmcloud CLI on the local system using Powershell.  Please run the following command to install it:</p> <pre><code>iex (New-Object Net.WebClient).DownloadString('https://clis.cloud.ibm.com/install/powershell')\n</code></pre> <p>Confirm the prompts, restart the Powershell window, and you should now have access to the <code>ibmcloud</code> cli.  Next, install the Code Engine plugin with the command: </p> <pre><code>ibmcloud plugin install code-engine\n</code></pre> <p>This tool will allow you to build an image of the application and upload it to a project.  The following procedure will walk through the steps to take your local application code and deploy it as a service.</p>"},{"location":"create-api/deploy-to-code-engine/#deploy-the-application","title":"Deploy the application","text":"<p>The first thing is to open the cloud shell, then set the resource group target.  Each student has been provided a resource group in the format of <code>itzwa-studentXX-&lt;rand_str&gt;</code>.  This can be found on the main resource list and each student will only have access to one group.  To select this run the commands: </p> <pre><code>ibmcloud login -u jason.leiby+studentXX@mail.test.ibm.com\nibmcloud target -g itzwa-studentXX-&lt;rand_str&gt;\nibmcloud ce project select -n itzwa-studentXX-&lt;rand_str&gt;-codeengine\n</code></pre> <p>The first line will will request the password provided to you for this lab, while the second will select the resource group created with the necessary resources.  The third line will select the project previously built.  Once all the necessary environment settings are selected, run the following commands to build an image of your source code and deploy the application.</p> <p><pre><code>ibmcloud ce buld create --name itzwa-studentXX-&lt;rand_str&gt; --build-type local\nibmcloud ce buildrun submit --name itzwa-studentXX-&lt;rand_str&gt; --build itzwa-studentXX-&lt;rand_str&gt; --source .\n</code></pre> From the second command, there will be an output provided that defines how to check on the build process.  Once the build is complete, the same command will provide the endpoint where the image is hosted.  This URL will be needed in the next command: </p> <pre><code>ibmcloud ce application create --name itzwa-studentXX-&lt;rand_str&gt;-app --image private.us.icr.io/&lt;namespace_string&gt;/build-itzwa-studentXX-&lt;rand_str&gt;  --registry-key lab1815-key\n</code></pre> Note <p>A registry key has already been created for your convenience.  Please use this to authenticate the application build commands</p> <p>You can now use the <code>shell ibmcloud ce app get</code> command (provided from the above command) to see the status of the deployment, and once finished, provide the URL details where the application can be reached.  Test the deployment with a <code>curl</code> command to ensure the service is running.  </p>"},{"location":"create-api/deploy-to-code-engine/#conclusion","title":"Conclusion","text":"<p>Now that the service is running, it is time to connect watsonx Assistant to the application and build an assistant!</p>"},{"location":"openapi-spec/create-spec/","title":"Lab 1815 - Creating the OpenAPI documentation","text":""},{"location":"openapi-spec/create-spec/#introduction-to-openapi","title":"Introduction to OpenAPI","text":"<p>OpenAPI is a specification that enables you to describe your API in a machine-readable format. It offers clear documentation and assists in development by generating client libraries and server stubs. OpenAPI adheres to RESTful principles and is typically used with JSON or YAML.  The specification will be written in JSON for the purposes of this lab as this is required by watsonx Assistant.  If you would prefer to write the spec in YAML, please ensure to convert it to JSON before importing it into the Assistant.  </p> Note <p>Working with YAML specifications will be outside the scope of this lab.</p>"},{"location":"openapi-spec/create-spec/#installation","title":"Installation","text":"<p>To start, ensure you have a text editor or integrated development environment (IDE) installed. You'll also need a basic understanding of JSON.  Visual Studio Code has already been installed on the virtual machine being used for this lab.</p>"},{"location":"openapi-spec/create-spec/#defining-api-information","title":"Defining API Information","text":"<p>Begin by defining general information about your API, such as its title, version, and description. This metadata helps users comprehend the API's purpose and usage.</p> <pre><code>{\n\"openapi\": \"3.0.0\",\n\"info\": {\n\"title\": \"My Awesome API\",\n\"version\": \"1.0.0\",\n\"description\": \"An API for demonstrating OpenAPI specifications.\"\n}\n}\n</code></pre>"},{"location":"openapi-spec/create-spec/#defining-paths-and-operations","title":"Defining Paths and Operations","text":"<p>Define the paths (endpoints) of your API and the operations (HTTP methods) that can be performed on them. Include request and response details, parameters, and more.</p> <pre><code>{\n\"paths\": {\n\"/users\": {\n\"get\": {\n\"summary\": \"Get a list of users\",\n\"responses\": {\n\"200\": {\n\"description\": \"Successful response\",\n\"content\": {\n\"application/json\": {\n\"example\": {\n\"users\": [\n{ \"id\": 1, \"name\": \"John Doe\" },\n{ \"id\": 2, \"name\": \"Jane Smith\" }\n]\n}\n}\n}\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"openapi-spec/create-spec/#handling-parameters","title":"Handling Parameters","text":"<p>Specify parameters that can be passed in the URL, query string, or request body. Parameters help customize API requests.</p> <pre><code>{\n\"paths\": {\n\"/users/{user_id}\": {\n\"parameters\": [\n{\n\"name\": \"user_id\",\n\"in\": \"path\",\n\"required\": true,\n\"schema\": {\n\"type\": \"integer\"\n},\n\"description\": \"ID of the user\"\n}\n],\n\"get\": {\n\"summary\": \"Get user by ID\",\n\"responses\": {\n\"200\": {\n\"description\": \"Successful response\",\n\"content\": {\n\"application/json\": {\n\"example\": {\n\"id\": 1,\n\"name\": \"John Doe\"\n}\n}\n}\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"openapi-spec/create-spec/#adding-request-bodies","title":"Adding Request Bodies","text":"<p>Describe request bodies for operations that require data to be sent in the request.</p> <pre><code>{\n\"paths\": {\n\"/users\": {\n\"post\": {\n\"summary\": \"Create a new user\",\n\"requestBody\": {\n\"required\": true,\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": { \"type\": \"string\" },\n\"email\": { \"type\": \"string\" }\n}\n}\n}\n}\n},\n\"responses\": {\n\"201\": {\n\"description\": \"User created successfully\"\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"openapi-spec/create-spec/#adding-responses","title":"Adding Responses","text":"<p>Define different response scenarios with corresponding HTTP status codes and content.</p> <pre><code>{\n\"paths\": {\n\"/users/{user_id}\": {\n\"get\": {\n\"summary\": \"Get user by ID\",\n\"responses\": {\n\"200\": {\n\"description\": \"Successful response\",\n\"content\": {\n\"application/json\": {\n\"example\": {\n\"id\": 1,\n\"name\": \"John Doe\"\n}\n}\n}\n},\n\"404\": {\n\"description\": \"User not found\"\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"openapi-spec/create-spec/#generating-documentation","title":"Generating Documentation","text":"<p>With your OpenAPI specification ready, you can generate interactive documentation using tools like Swagger UI or ReDoc.</p>"},{"location":"openapi-spec/create-spec/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've learned the fundamentals of writing OpenAPI 3.0 specifications using JSON examples. For more advanced features and detailed documentation, refer to the official OpenAPI Specification.</p> <p>Practice is key. Experiment with different features and create more complex API specifications to enhance your skills.</p>"}]}